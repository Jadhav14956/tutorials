In this tutorial, we will learn how to write tests for React Components. We'll keep it simple and have webpack.config.js and package.json files we can actually understand.

Test Driven Development
So what's the big deal about Test Driven Development (TDD)? There are a lot of great articles and books on TDD, but here are some benefits I see from it.

1. Create better code.
When you are writing tests first, you keep your code focused on what you are doing. I've been in situations where I code by coincidence; I keep writing code until it works...assuming I remember what the goal of my code was. TDD will keep you on track and cut fat from your code.

2. Create cleaner code.
When you have well designed tests that are passing, you know that you can safely refactor your code. How many times have you refactored your working code, only to break everything? TDD gives you the vital signs of your code and warns you when something is wrong; it's a great way to prevent regressions in your code.

3. It's fun.
Creating code is a long, tough process, and it may take awhile for you to see progress in your project. TDD gives you instant feedback that you are going in the right direction. Seeing your tests pass gives you tiny victories and makes coding, for me, a lot more enjoyable.

Do note that TDD isn't solely about unit tests. I like to think of TDD as a mindset where you code clean, succinct code with a purpose. Unit tests are a side effect of TDD.

Testing React components is simple because React components are pure functions. When you have Stateless/Presentational components, they are just functions that should return the same result given certain inputs.

Mocha
For this tutorial, we'll be using Mocha, which is a testing framework that we will be running in Node.js. Make sure to download this globally, so you're able to run mocha from your command line. $npm install -g mocha
To set this up, in your package.json, you'll want to write a script.
This testing script will run mocha.
--watch : the watch flag will look for any changes to our files. If any of the files have changed, mocha will automatically rerun the tests and output the results.
--require : this tag will include any files that are needed for the tests. We will include babel here, so that our code will be transformed from ES6/JSX code, to ES5.

Chai
Chai is an assertion library that will help us write our tests in something that reads more like English.

JSDOM!!!!
We will be using JSDOM, which is a mock of the DOM and HTML.

Source code that we will test
We have 3 simple components to test. A Todo item, that just displays text.
A TodoList that will display a list of Todo items.
An AddTodo component, which has an input field and a button. This component has a callback when the button is clicked.

Tests To Run
Todo Component. What do we want to test?

With simple stateless components, we probably want to test if the <div> tag from the Todo component is rendered, and if it rendered the correct text.
We will use the "react-addons-test-utils" to help us. We'll use the "renderIntoDocument" function to render our Todo Component into our JSDOM.

"react-addons-test-utils" also gives us some tools to traverse through our DOM. Let's use scryRenderedDOMComponentsWithClass. This will search our DOM element for anything with a class of "todo". We'll check that we actually found one.

```
const todo = scryRenderedDOMComponentsWithClass(component, 'todo');
expect(todo.length).to.equal(1);
```

Let's also check that the text content is what we expect it to be.

```
const todoText = todo[0].textContent;
expect(todoText).to.equal('Mow lawn');
```

Simple enough. Let's move onto the TodoList.

TodoList Component. What do we want to test?
There's a lot to test, but I want to make sure that we're getting a Todo component for each todo item that we have.
So let's create a TodoList component, and pass in 3 todo items. We would expect 3 Todo components to be created. Let's use another method from the react utils, "scryRenderedComponentsWithType". This will look through our DOM, and find us all of the DOM items that are of the "Todo" component.

```
const todos = scryRenderedComponentsWithType(component, Todo);
expect(todos.length).to.equal(3);
```

Now with the AddTodo component. I want to test if the input field and button is properly rendered onto DOM. Once again, the react utils provides us with a method, "scryRenderedDOMComponentsWithTag", which looks for an element with a given HTML tag.

```
const button = scryRenderedDOMComponentsWithTag(component, 'button');
expect(button.length).to.equal(1);
const inputField = scryRenderedDOMComponentsWithTag(component, 'input');
expect(inputField.length).to.equal(1);
```

Let's also check that the button has the correct text. We can do this easily, like we did with the Todo component.

```
const buttonText = button[0].textContent;
expect(buttonText).to.equal('Add Todo');
```

Now, we want to test if this Add Todo button will actually work. Remember that the AddTodo component is a stateless component. This is important because it means it's super easy to test. The AddTodo component is just accepting a callback as a prop, which will be run whenever the button is clicked. Because of this, we can easily mock a method.

```
let addInvoked = false;
let callback = (text) => { addInvoked = text };

```

So I have a variable, addInvoked. This will keep track of whether my callback was actually called or not. When the callback is called, it will change the addInvoked variable into the text inside the AddTodo component's input field.

Now, you might be wondering how we're going to get this button to be clicked, and test if the callback is properly invoked. Again, react-utils has a powerful method, "Simulate" that will simulate these DOM actions for us.

First let's input a value into the text field. We can do this by grabbing the input field, and updating its value. And then using Simulate.change to update the value in the DOM.

```
inputField.value = 'Mow lawn';
Simulate.change(inputField);
```

Now, let's click on the Add Todo button.

```
Simulate.click(button);
```

We expect the callback to have been called when the button is clicked. We also expect that the text of the input field is passed as an argument to our callback.

```
expect(addInvoked).to.equal('Mow lawn');
```

And that's it. This was a simple introduction to testing React Components. I hope this helps you understand one of the benefits of working with Stateless components. It's so easy to set up tests and easily mock any callbacks that's necessary. Testing AJAX calls and redux reducers are pretty much the same.
